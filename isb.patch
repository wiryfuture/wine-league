From d2774edb771bcccf55b762ef2b7056aefe4d559f Mon Sep 17 00:00:00 2001
From: Philip Wilk <wiryfuture@gmail.com>
Date: Mon, 29 Nov 2021 17:37:41 +0000
Subject: [PATCH 1/4] bodge isb query

---
 dlls/ws2_32/socket.c | 223 ++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 222 insertions(+), 1 deletion(-)

diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index 2db441bee3c..148c960396f 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -1519,7 +1519,7 @@ int WINAPI getsockopt( SOCKET s, int level, int optname, char *optval, int *optl
                 SetLastError(WSAEFAULT);
                 return SOCKET_ERROR;
             }
-            TRACE("getting global SO_MAX_MSG_SIZE = 65507\n");
+            TRACE("getting global SO_MAX_MSG_SIZE = 65507\n"); /* This doesn't look right */
             *(int *)optval = 65507;
             *optlen = sizeof(int);
             return 0;
@@ -2257,6 +2257,227 @@ INT WINAPI WSAIoctl(SOCKET s, DWORD code, LPVOID in_buff, DWORD in_size, LPVOID
         return ret ? -1 : 0;
     }
 
+    /* Get (S)end (B)acklog (V)alue of the socket connection */
+    /* The League of Legends client calls this for some god forsaken reason */
+    /* Params:
+        - SOCKET; socket = s
+            Socket identifer
+        - DWORD; dwIoControlCode = code; (SIO_IDEAL_SEND_BACKLOG_QUERY)
+        !UNUSED - LPVOID; lpvInBuffer = in_buff; (NULL)
+        !UNUSED - DWORD; cbInBuffer = in_size; (0)
+        - LPVOID; output buffer = out_buff
+            Should be ULONG type if overlapped or completion params are null
+        - DWORD; output buffer size = out_size 
+            Should be at least ULONG size
+        - LPDWORD; bytes returned = ret_size
+            Number of bytes stored in output buffer
+                Small output buffer => DWORD (0)
+                overlapped = null => DWORD != 0
+                overlapped != null => completion may occur later DWORD may be 0
+                    Status can be retrieved when completion method has completed
+        - LPWSAOVERLAPPED; overlapped struct = overlapped
+            socket has no overlapped attrib. => ignore param
+            socket has overlap attrib. => perform as async, must be valid wsaoverlapped struct
+                return immediately, completion method exec. on operation completion 
+                    function does not return until operation returns or errors
+        - LPWSAOVERLAPPED;_COMPLETION_ROUTINE completion routine = completion
+            pointer to completion routine, ran when completion occurs
+            non-overlapped socket => ignore param
+
+      Returns:
+        - Success = (0)
+        - Fail or pending = SOCKET_ERROR
+            Err Codes:
+                - WSA_IO_PENDING = overlapped operation intitiated, will be completed later
+                - WSA_OPERATION_ABORTED = overlapped operation stopped due to socket closure or SIO_FLUSH IOCTL command
+            /   - WSAEFAULT = inbuffer, outbuffer, bytesreturned, overlapped or completion param isn't fully in user(address)space
+                    Hopefully the 'borrowed' code can do this sufficiently
+            ?   - WSAEINPROGRESS = function invoked while callback in process
+                    how do you check if a blocking func. is in progress?
+                        Doesn't seem to be a practical way to do this...
+            x   - WSAEINTR = blocking operation interrupted
+                    WSACancelBlockingCall was removed in ws2 rev 2.2.0, can still be used in winsock.dll and wsock32.dll
+            /   - WSAEINVAL = control code param is not a valid command, or is not acceptable, or applicable to this socket.
+                    outbuffer < ULONG datatype size/length => WSAEINVAL
+            ?   - WSAENETDOWN = network subsytem failed
+                    How do you even handle this
+            /   - WSAENOPROTOOPT = socket option not supported on selected protocol
+                    On 1.1 there are only SOCK_DGRAM and SOCK_STREAM
+                    On 2>= there is SOCK_STREAM, SOCK_DGRAM, SOCK_RAW, SOCK_RDM and SOCK_SEQPACKET
+            /   - (kinda) - WSAENOTCONN = socket not connected
+            /   - WSAENOTSOCK = socket param is not a socket
+            ?   - WSAEOPNOTSUPP = IOCTL command is not supported; when this ioctl is not supported by the transport provider or this ioctl is run on a datagram socket
+                    When the socket is a datagram, it should get error WSAENOPROTOOPT anyway??
+    */
+    case SIO_IDEAL_SEND_BACKLOG_QUERY:
+    {
+        /* 
+            I think this basically checks if the socket param is actually a socket because other error WSAENOTSOCK code use it 
+        */
+        if ( !socket_list_find( s ) )
+        {
+            SetLastError( WSAENOTSOCK );
+            return -1;
+        }
+        if (overlapped) 
+        {
+            SetLastError(  )
+        }
+        /*
+            Polls for if a socket closes to throw the WSA_OPERATION_ABORTED error
+                Somehow this needs to be able to be given close and SIO_FLUSH IOCTL events
+        */ /* 
+        if ( () => { 
+            int WSAAPIevents = WSAEventSelect(s, null, FD_CLOSE )
+        }) 
+        {
+            SetLastError( WSA_OPERATION_ABORTED );
+            return -1;
+        } */
+        /*
+            Just stealing this from elsewhere in this dll ( i think it just checks the params exist? )
+                Even simpler though so definitely can incur errors (with the sizes i think)
+        */
+        if (!in_buff || !in_size || !out_buff || !out_size)
+        {
+            SetLastError( WSAEFAULT );
+            return -1;
+        }
+        /* 
+            Convert outbuffer to byte array, then compare its length to the length of ULONG (8bytes/64bits)
+        */
+        if (BitConverter.GetBytes(outbuffer).length < 8)
+        {
+            SetLastError( WSAEINVAL );
+            return -1;
+        }
+        /*
+            Check connection is open
+                - accept con is false
+                - pause accept is true
+                - conditional accept is true
+                Not sure if we should check for SO_BROADCAST being false also (left that under just in case)
+
+            There **HAS** to be a better way of doing this, surely?
+        */
+        int optLen = sizeof(int); /* integer datatype size */
+        if (
+            () = {
+            return (
+                !(() => { 
+                    int optVal;
+                    getsockopt(s, SOL_SOCKET, SO_ACCEPTCONN, (char*)&optVal, &optLen);
+                    return optVal;
+                }) &&
+                (() => {
+                    int optVal;
+                    getsockopt(s, SOL_SOCKET, SO_PAUSE_ACCEPT, (char*)&optVal, &optLen);
+                    return optVal;
+                }) &&
+                (() => {
+                    int optVal;
+                    getsockopt(s, SOL_SOCKET, SO_CONDITIONAL_ACCEPT, (char*)&optVal, &optLen);
+                    return optVal;
+                })/* &&
+                !(() => {
+                    int optVal;
+                    getsockopt(s, SOL_SOCKET, SO_BROADCAST, (char*)&optVal, &optLen);
+                    return optVal;
+                })*/
+            )};
+        )
+        {
+            SetLastError( WSAENOTCONN );
+            return -1;
+        }
+        /*
+            Check if socket uses an unsupported protocol (datagram-types)
+        */
+        if (
+            (() => {
+                WSAPROTOCOL_INFOW info;
+                if (!ws_protocol_info( s, TRUE, &info, &optLen )) return -1;
+                /* I think these are all the datagram types  */
+                if (info.iSocketType == SOCK_DGRAM || info.iSocketType == SOCK_RDM || info.iSocketType == SOCK_SEQPACKET) return true
+            })
+        )
+        {
+            SetLastError( WSAENOPROTOOPT );
+            return -1;
+        }  
+        /*
+            Get receive buffer
+        */
+        int RBUFF;
+        getsockopt( s, SOL_SOCKET, SO_RCVBUF, (char*)&RBUFF, &optLen);
+        /*
+            Get send buffer
+        */
+        int SBUFF;
+        getsockopt( s, SOL_SOCKET, SO_SNDBUF, (char*)&SBUFF, &optlen);
+        /*
+            Get max (socket) message size
+        */
+        int MAXMSGSIZE;
+        getsockopt( s, SOL_SOCKET, SO_MAX_MSG_SIZE, (char*)&MAXMSGSIZE, &optlen);
+
+        if ( !RBUFF || !SBUFF || !MAXMSGSIZE ) 
+        {
+            return SOCKET_ERROR;
+        }
+
+        /*
+            Ideally, this should go a bit like this:
+                receive window = receive buffer - (last_byte_received - last_byte_read)
+                int RWND = RBUFF - (LST_BYT_REC - LST_BYT_RD);
+    
+                If server bandwidth is higher than user bandwidth, use user bandwidth as max. 
+                if user bandwidth higher than server, use server bandwidth. 
+                ISB = (RBUFF / BDWDTH_DLY) > 1 ? BDWIDTH_DLY : RBUF;
+
+                set SOCK BUFFER to ISB; via SIO_IDEAL_SEND_BACKLOG_CHANGE ?? or is this meant to somehow send it back to the caller; but it's meant to return 0??
+                EXEC COMPLETION_ROUTINE;
+        */
+        out_buff = SBUFF;
+        if (RBUFF > SBUFF) /* very low effort bodge? */
+        {
+            /* Increase the ideal send buffer size by half the diff between send buff and rec buff */
+            out_buff += (RBUFF - SBUFF) * 0.5;
+            /* TODO:  use some sort of anti-congestion algorithm to get a better estimate for an ideal sbuff */
+        }
+        /*
+            If overlap true and completion func present, do completion func
+        */
+        if ( overlapped & completion )
+        {
+            SetLastError( WSA_IO_PENDING );
+            piosb = (IO_STATUS_BLOCK *)overlapped;
+            if (!((ULONG_PTR)overlapped->hEvent & 1)) cvalue = overlapped;
+            event = overlapped->hEvent;
+            
+            piosb->u.Status = STATUS_PENDING;
+
+            event = NULL;
+            cvalue = completion;
+            apc = socket_apc;
+        
+            status = NtDeviceIoControlFile( (HANDLE)s, event, apc, cvalue, piosb,
+                                    IOCTL_AFD_WINE_RECVMSG, &params, sizeof(params), NULL, 0 );
+            if (status == STATUS_PENDING && !overlapped)
+            {
+                if (WaitForSingleObject( event, INFINITE ) == WAIT_FAILED)
+                    return -1;
+                status = piosb->u.Status;
+            }
+            if (!status && ret_size) *ret_size = piosb->Information;
+            SetLastError( NtStatusToWSAError( status ) );
+            return status ? -1 : 0;
+        }
+        else {
+            return 0;
+        }
+    }
+
     default:
         FIXME( "unimplemented ioctl %s\n", debugstr_wsaioctl( code ) );
         /* fall through */
-- 
2.33.1


From 3025eb6ec3d15cdaa9f8a56991277b4cec05d6c8 Mon Sep 17 00:00:00 2001
From: Philip Wilk <wiryfuture@gmail.com>
Date: Mon, 29 Nov 2021 18:26:00 +0000
Subject: [PATCH 2/4] make overlap completion func simpler

---
 dlls/ws2_32/socket.c | 86 ++++++++++++++------------------------------
 1 file changed, 27 insertions(+), 59 deletions(-)

diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index 148c960396f..9c79ffebb7f 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -2311,6 +2311,14 @@ INT WINAPI WSAIoctl(SOCKET s, DWORD code, LPVOID in_buff, DWORD in_size, LPVOID
     */
     case SIO_IDEAL_SEND_BACKLOG_QUERY:
     {
+        int RBUFF;
+        int SBUFF;
+        int MAXMSGSIZE;
+        int optLen = int; /* integer datatype size */
+        int optVal1;
+        int optVal2;
+        int optVal3;
+        /*int optVal4;*/
         /* 
             I think this basically checks if the socket param is actually a socket because other error WSAENOTSOCK code use it 
         */
@@ -2319,10 +2327,6 @@ INT WINAPI WSAIoctl(SOCKET s, DWORD code, LPVOID in_buff, DWORD in_size, LPVOID
             SetLastError( WSAENOTSOCK );
             return -1;
         }
-        if (overlapped) 
-        {
-            SetLastError(  )
-        }
         /*
             Polls for if a socket closes to throw the WSA_OPERATION_ABORTED error
                 Somehow this needs to be able to be given close and SIO_FLUSH IOCTL events
@@ -2346,7 +2350,7 @@ INT WINAPI WSAIoctl(SOCKET s, DWORD code, LPVOID in_buff, DWORD in_size, LPVOID
         /* 
             Convert outbuffer to byte array, then compare its length to the length of ULONG (8bytes/64bits)
         */
-        if (BitConverter.GetBytes(outbuffer).length < 8)
+        if (BitConverter.GetBytes(out_buff).length < 8)
         {
             SetLastError( WSAEINVAL );
             return -1;
@@ -2360,32 +2364,17 @@ INT WINAPI WSAIoctl(SOCKET s, DWORD code, LPVOID in_buff, DWORD in_size, LPVOID
 
             There **HAS** to be a better way of doing this, surely?
         */
-        int optLen = sizeof(int); /* integer datatype size */
-        if (
-            () = {
-            return (
-                !(() => { 
-                    int optVal;
-                    getsockopt(s, SOL_SOCKET, SO_ACCEPTCONN, (char*)&optVal, &optLen);
-                    return optVal;
-                }) &&
-                (() => {
-                    int optVal;
-                    getsockopt(s, SOL_SOCKET, SO_PAUSE_ACCEPT, (char*)&optVal, &optLen);
-                    return optVal;
-                }) &&
-                (() => {
-                    int optVal;
-                    getsockopt(s, SOL_SOCKET, SO_CONDITIONAL_ACCEPT, (char*)&optVal, &optLen);
-                    return optVal;
-                })/* &&
-                !(() => {
-                    int optVal;
-                    getsockopt(s, SOL_SOCKET, SO_BROADCAST, (char*)&optVal, &optLen);
-                    return optVal;
-                })*/
-            )};
-        )
+    
+        getsockopt(s, SOL_SOCKET, SO_ACCEPTCONN, (char*)&optVal, &optLen1);
+        
+        getsockopt(s, SOL_SOCKET, SO_PAUSE_ACCEPT, (char*)&optVal, &optLen2);
+        
+        getsockopt(s, SOL_SOCKET, SO_CONDITIONAL_ACCEPT, (char*)&optVal, &optLen3);
+        /*
+        getsockopt(s, SOL_SOCKET, SO_BROADCAST, (char*)&optVal, &optLen4);
+        */
+
+        if ( !optVal1 && optVal2 && optVal3 /* && !optVal4*/)
         {
             SetLastError( WSAENOTCONN );
             return -1;
@@ -2408,18 +2397,16 @@ INT WINAPI WSAIoctl(SOCKET s, DWORD code, LPVOID in_buff, DWORD in_size, LPVOID
         /*
             Get receive buffer
         */
-        int RBUFF;
         getsockopt( s, SOL_SOCKET, SO_RCVBUF, (char*)&RBUFF, &optLen);
         /*
             Get send buffer
         */
-        int SBUFF;
-        getsockopt( s, SOL_SOCKET, SO_SNDBUF, (char*)&SBUFF, &optlen);
+        getsockopt( s, SOL_SOCKET, SO_SNDBUF, (char*)&SBUFF, &optLen);
         /*
             Get max (socket) message size
         */
-        int MAXMSGSIZE;
-        getsockopt( s, SOL_SOCKET, SO_MAX_MSG_SIZE, (char*)&MAXMSGSIZE, &optlen);
+
+        getsockopt( s, SOL_SOCKET, SO_MAX_MSG_SIZE, (char*)&MAXMSGSIZE, &optLen);
 
         if ( !RBUFF || !SBUFF || !MAXMSGSIZE ) 
         {
@@ -2438,11 +2425,11 @@ INT WINAPI WSAIoctl(SOCKET s, DWORD code, LPVOID in_buff, DWORD in_size, LPVOID
                 set SOCK BUFFER to ISB; via SIO_IDEAL_SEND_BACKLOG_CHANGE ?? or is this meant to somehow send it back to the caller; but it's meant to return 0??
                 EXEC COMPLETION_ROUTINE;
         */
-        out_buff = SBUFF;
+        out_buff = (int*)SBUFF;
         if (RBUFF > SBUFF) /* very low effort bodge? */
         {
             /* Increase the ideal send buffer size by half the diff between send buff and rec buff */
-            out_buff += (RBUFF - SBUFF) * 0.5;
+            out_buff += (int*)((RBUFF - SBUFF) * 0.5);
             /* TODO:  use some sort of anti-congestion algorithm to get a better estimate for an ideal sbuff */
         }
         /*
@@ -2451,27 +2438,8 @@ INT WINAPI WSAIoctl(SOCKET s, DWORD code, LPVOID in_buff, DWORD in_size, LPVOID
         if ( overlapped & completion )
         {
             SetLastError( WSA_IO_PENDING );
-            piosb = (IO_STATUS_BLOCK *)overlapped;
-            if (!((ULONG_PTR)overlapped->hEvent & 1)) cvalue = overlapped;
-            event = overlapped->hEvent;
-            
-            piosb->u.Status = STATUS_PENDING;
-
-            event = NULL;
-            cvalue = completion;
-            apc = socket_apc;
-        
-            status = NtDeviceIoControlFile( (HANDLE)s, event, apc, cvalue, piosb,
-                                    IOCTL_AFD_WINE_RECVMSG, &params, sizeof(params), NULL, 0 );
-            if (status == STATUS_PENDING && !overlapped)
-            {
-                if (WaitForSingleObject( event, INFINITE ) == WAIT_FAILED)
-                    return -1;
-                status = piosb->u.Status;
-            }
-            if (!status && ret_size) *ret_size = piosb->Information;
-            SetLastError( NtStatusToWSAError( status ) );
-            return status ? -1 : 0;
+            completion; /* how do i thread this? */
+            return -1;
         }
         else {
             return 0;
-- 
2.33.1


From b8d55a130f2e32db0b2046fe19aa8853097b71aa Mon Sep 17 00:00:00 2001
From: Philip Wilk <wiryfuture@gmail.com>
Date: Mon, 29 Nov 2021 18:48:25 +0000
Subject: [PATCH 3/4] bad code

---
 dlls/ws2_32/socket.c | 43 +++++++++++++++++++++----------------------
 1 file changed, 21 insertions(+), 22 deletions(-)

diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index 9c79ffebb7f..30f5a68951a 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -2314,11 +2314,13 @@ INT WINAPI WSAIoctl(SOCKET s, DWORD code, LPVOID in_buff, DWORD in_size, LPVOID
         int RBUFF;
         int SBUFF;
         int MAXMSGSIZE;
-        int optLen = int; /* integer datatype size */
+        int optLen; /* integer datatype size */
         int optVal1;
         int optVal2;
-        int optVal3;
-        /*int optVal4;*/
+        /*int optVal3;*/
+        optLen = sizeof(int);
+        WSAPROTOCOL_INFOW info;
+
         /* 
             I think this basically checks if the socket param is actually a socket because other error WSAENOTSOCK code use it 
         */
@@ -2348,9 +2350,9 @@ INT WINAPI WSAIoctl(SOCKET s, DWORD code, LPVOID in_buff, DWORD in_size, LPVOID
             return -1;
         }
         /* 
-            Convert outbuffer to byte array, then compare its length to the length of ULONG (8bytes/64bits)
+            Get byte size of out_buff, compare to the length of ULONG (8bytes/64bits)
         */
-        if (BitConverter.GetBytes(out_buff).length < 8)
+        if (sizeof(out_buff) < 8)
         {
             SetLastError( WSAEINVAL );
             return -1;
@@ -2365,16 +2367,14 @@ INT WINAPI WSAIoctl(SOCKET s, DWORD code, LPVOID in_buff, DWORD in_size, LPVOID
             There **HAS** to be a better way of doing this, surely?
         */
     
-        getsockopt(s, SOL_SOCKET, SO_ACCEPTCONN, (char*)&optVal, &optLen1);
-        
-        getsockopt(s, SOL_SOCKET, SO_PAUSE_ACCEPT, (char*)&optVal, &optLen2);
+        getsockopt(s, SOL_SOCKET, SO_ACCEPTCONN, (char*)&optVal1, &optLen);
         
-        getsockopt(s, SOL_SOCKET, SO_CONDITIONAL_ACCEPT, (char*)&optVal, &optLen3);
+        getsockopt(s, SOL_SOCKET, SO_CONDITIONAL_ACCEPT, (char*)&optVal2, &optLen);
         /*
-        getsockopt(s, SOL_SOCKET, SO_BROADCAST, (char*)&optVal, &optLen4);
+        getsockopt(s, SOL_SOCKET, SO_BROADCAST, (char*)&optVal3, &optLen);
         */
 
-        if ( !optVal1 && optVal2 && optVal3 /* && !optVal4*/)
+        if ( !optVal1 && optVal2 /* && !optVal3*/)
         {
             SetLastError( WSAENOTCONN );
             return -1;
@@ -2382,14 +2382,13 @@ INT WINAPI WSAIoctl(SOCKET s, DWORD code, LPVOID in_buff, DWORD in_size, LPVOID
         /*
             Check if socket uses an unsupported protocol (datagram-types)
         */
+        if (!ws_protocol_info( s, TRUE, &info, &optLen )) return -1;
+        /* I think these are all the datagram types  */
         if (
-            (() => {
-                WSAPROTOCOL_INFOW info;
-                if (!ws_protocol_info( s, TRUE, &info, &optLen )) return -1;
-                /* I think these are all the datagram types  */
-                if (info.iSocketType == SOCK_DGRAM || info.iSocketType == SOCK_RDM || info.iSocketType == SOCK_SEQPACKET) return true
-            })
-        )
+            info.iSocketType == SOCK_DGRAM || 
+            info.iSocketType == SOCK_RDM || 
+            info.iSocketType == SOCK_SEQPACKET
+        ) 
         {
             SetLastError( WSAENOPROTOOPT );
             return -1;
@@ -2425,20 +2424,20 @@ INT WINAPI WSAIoctl(SOCKET s, DWORD code, LPVOID in_buff, DWORD in_size, LPVOID
                 set SOCK BUFFER to ISB; via SIO_IDEAL_SEND_BACKLOG_CHANGE ?? or is this meant to somehow send it back to the caller; but it's meant to return 0??
                 EXEC COMPLETION_ROUTINE;
         */
-        out_buff = (int*)SBUFF;
+        out_buff = SBUFF;
         if (RBUFF > SBUFF) /* very low effort bodge? */
         {
             /* Increase the ideal send buffer size by half the diff between send buff and rec buff */
-            out_buff += (int*)((RBUFF - SBUFF) * 0.5);
+            out_buff += floor((RBUFF - SBUFF) * 0.5);
             /* TODO:  use some sort of anti-congestion algorithm to get a better estimate for an ideal sbuff */
         }
         /*
             If overlap true and completion func present, do completion func
         */
-        if ( overlapped & completion )
+        if ( overlapped && completion )
         {
             SetLastError( WSA_IO_PENDING );
-            completion; /* how do i thread this? */
+            /*completion;  how do you use the completion param? */
             return -1;
         }
         else {
-- 
2.33.1


From 418c16b6fbd5a4b99acbefa8bebf4b61eeb7481b Mon Sep 17 00:00:00 2001
From: Philip Wilk <wiryfuture@gmail.com>
Date: Mon, 29 Nov 2021 19:03:20 +0000
Subject: [PATCH 4/4] declare before code

---
 dlls/ws2_32/socket.c | 13 ++++++++++---
 1 file changed, 10 insertions(+), 3 deletions(-)

diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index 30f5a68951a..443f47a7f54 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -27,6 +27,7 @@
  */
 
 #include "ws2_32_private.h"
+#include <math.h>
 
 #define FILE_USE_FILE_POINTER_POSITION ((LONGLONG)-2)
 
@@ -2311,16 +2312,21 @@ INT WINAPI WSAIoctl(SOCKET s, DWORD code, LPVOID in_buff, DWORD in_size, LPVOID
     */
     case SIO_IDEAL_SEND_BACKLOG_QUERY:
     {
+        /* Declarations */
         int RBUFF;
         int SBUFF;
         int MAXMSGSIZE;
+        int ISB;
         int optLen; /* integer datatype size */
         int optVal1;
         int optVal2;
         /*int optVal3;*/
-        optLen = sizeof(int);
         WSAPROTOCOL_INFOW info;
 
+        /* Code */
+        optLen = sizeof(int);
+        
+
         /* 
             I think this basically checks if the socket param is actually a socket because other error WSAENOTSOCK code use it 
         */
@@ -2424,13 +2430,14 @@ INT WINAPI WSAIoctl(SOCKET s, DWORD code, LPVOID in_buff, DWORD in_size, LPVOID
                 set SOCK BUFFER to ISB; via SIO_IDEAL_SEND_BACKLOG_CHANGE ?? or is this meant to somehow send it back to the caller; but it's meant to return 0??
                 EXEC COMPLETION_ROUTINE;
         */
-        out_buff = SBUFF;
+        ISB = SBUFF;
         if (RBUFF > SBUFF) /* very low effort bodge? */
         {
             /* Increase the ideal send buffer size by half the diff between send buff and rec buff */
-            out_buff += floor((RBUFF - SBUFF) * 0.5);
+            ISB += (int) floor((RBUFF - SBUFF) * 0.5);
             /* TODO:  use some sort of anti-congestion algorithm to get a better estimate for an ideal sbuff */
         }
+        out_buff = &ISB;
         /*
             If overlap true and completion func present, do completion func
         */
-- 
2.33.1

