From 9351ea92b36e2da642f59408095162c4f5498614 Mon Sep 17 00:00:00 2001
From: Philip Wilk <wiryfuture@gmail.com>
Date: Wed, 22 Dec 2021 15:33:57 +0000
Subject: [PATCH] timeout on GetAddrInfoExW

---
 dlls/ws2_32/protocol.c | 197 ++++++++++++++++++++++++++++++++++++++---
 1 file changed, 186 insertions(+), 11 deletions(-)

diff --git a/dlls/ws2_32/protocol.c b/dlls/ws2_32/protocol.c
index 492400b17a7..79bd00ba93c 100644
--- a/dlls/ws2_32/protocol.c
+++ b/dlls/ws2_32/protocol.c
@@ -18,19 +18,30 @@
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
+ * License along with this librIary; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
 #include "ws2_32_private.h"
+#include "windows.h"
+#include "winbase.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(winsock);
 WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
+typedef struct getaddrinfoWParams {
+    const WCHAR *nodename;
+    const WCHAR *servname;
+    const struct addrinfoexW *hints;
+    struct addrinfoexW **res;
+    OVERLAPPED *overlapped;
+    LPLOOKUPSERVICE_COMPLETION_ROUTINE completion_routine;
+} getaddrinfoWParams;
+
+static DWORD WINAPI getaddrinfoW_wSTRUCT( LPVOID pParam );
 unixlib_handle_t ws_unix_handle = 0;
 
 #define WS_CALL(func, params) __wine_unix_call( ws_unix_handle, ws_unix_ ## func, params )
-
 static char *get_fqdn(void)
 {
     char *ret;
@@ -394,6 +405,113 @@ end:
     return ret;
 }
 
+static DWORD WINAPI getaddrinfoW_wSTRUCT( LPVOID pParam )
+{
+    int ret = EAI_MEMORY, len, i;
+    char *nodenameA = NULL, *servnameA = NULL;
+    struct addrinfo *resA;
+    struct getaddrinfoWParams *context = (struct getaddrinfoWParams) pParam;
+    WCHAR *local_nodenameW = context->nodename;
+
+    context->res = NULL;
+    if (context->nodename)
+    {
+        /* Is this an IDN? Most likely if any char is above the Ascii table, this
+         * is the simplest validation possible, further validation will be done by
+         * the native getaddrinfo() */
+        for (i = 0; context->nodename[i]; i++)
+        {
+            if (context->nodename[i] > 'z')
+                break;
+        }
+        if (context->nodename[i])
+        {
+            if (context->hints && (context->hints->ai_flags & AI_DISABLE_IDN_ENCODING))
+            {
+                /* Name requires conversion but it was disabled */
+                ret = WSAHOST_NOT_FOUND;
+                SetLastError( ret );
+                goto end;
+            }
+
+            len = IdnToAscii( 0, context->nodename, -1, NULL, 0 );
+            if (!len)
+            {
+                ERR("Failed to convert %s to punycode\n", debugstr_w(context->nodename));
+                ret = EAI_FAIL;
+                goto end;
+            }
+            if (!(local_nodenameW = malloc( len * sizeof(WCHAR) ))) goto end;
+            IdnToAscii( 0, context->nodename, -1, local_nodenameW, len );
+        }
+    }
+    if (local_nodenameW)
+    {
+        len = WideCharToMultiByte( CP_ACP, 0, local_nodenameW, -1, NULL, 0, NULL, NULL );
+        if (!(nodenameA = malloc( len ))) goto end;
+        WideCharToMultiByte( CP_ACP, 0, local_nodenameW, -1, nodenameA, len, NULL, NULL );
+    }
+    if (context->servname)
+    {
+        len = WideCharToMultiByte( CP_ACP, 0, context->servname, -1, NULL, 0, NULL, NULL );
+        if (!(servnameA = malloc( len ))) goto end;
+        WideCharToMultiByte( CP_ACP, 0, context->servname, -1, servnameA, len, NULL, NULL );
+    }
+
+    if (context->overlapped)
+    {
+        struct getaddrinfo_args *args;
+
+        if (context->overlapped->hEvent && context->completion_routine)
+        {
+            ret = WSAEINVAL;
+            goto end;
+        }
+
+        if (!(args = malloc( sizeof(*args) + sizeof(*args->hints) ))) goto end;
+        args->overlapped = context->overlapped;
+        args->completion_routine = context->completion_routine;
+        args->result = context->res;
+        args->nodename = nodenameA;
+        args->servname = servnameA;
+        if (context->hints)
+        {
+            args->hints = (struct addrinfo *)(args + 1);
+            args->hints->ai_flags    = context->hints->ai_flags;
+            args->hints->ai_family   = context->hints->ai_family;
+            args->hints->ai_socktype = context->hints->ai_socktype;
+            args->hints->ai_protocol = context->hints->ai_protocol;
+        }
+        else args->hints = NULL;
+
+        context->overlapped->Internal = WSAEINPROGRESS;
+        if (!TrySubmitThreadpoolCallback( getaddrinfo_callback, args, NULL ))
+        {
+            free( args );
+            ret = GetLastError();
+            goto end;
+        }
+
+        if (local_nodenameW != context->nodename)
+            free( local_nodenameW );
+        SetLastError( ERROR_IO_PENDING );
+        return (DWORD)ERROR_IO_PENDING;
+    }
+
+    ret = getaddrinfo( nodenameA, servnameA, context->hints, &resA );
+    if (!ret)
+    {
+        context->res = addrinfo_list_AtoW( resA );
+        freeaddrinfo( resA );
+    }
+
+end:
+    if (local_nodenameW != context->nodename)
+        free( local_nodenameW );
+    free( nodenameA );
+    free( servnameA );
+    return (DWORD)ret;
+}
 
 /***********************************************************************
  *      GetAddrInfoExW   (ws2_32.@)
@@ -404,6 +522,13 @@ int WINAPI GetAddrInfoExW( const WCHAR *name, const WCHAR *servname, DWORD names
                            LPLOOKUPSERVICE_COMPLETION_ROUTINE completion_routine, HANDLE *handle )
 {
     int ret;
+    LPDWORD *exitCode;
+    HANDLE getaddrinfoW_thread;
+    LARGE_INTEGER Frequency;
+    LARGE_INTEGER StartingTime;
+    LARGE_INTEGER EndingTime;
+    LARGE_INTEGER ElapsedMicroseconds;
+    struct getaddrinfoWParams getaddrinfoWParams_struct;
 
     TRACE( "name %s, servname %s, namespace %u, namespace_id %s)\n",
            debugstr_w(name), debugstr_w(servname), namespace, debugstr_guid(namespace_id) );
@@ -412,15 +537,65 @@ int WINAPI GetAddrInfoExW( const WCHAR *name, const WCHAR *servname, DWORD names
         FIXME( "Unsupported namespace %u\n", namespace );
     if (namespace_id)
         FIXME( "Unsupported namespace_id %s\n", debugstr_guid(namespace_id) );
-    if (timeout)
-        FIXME( "Unsupported timeout\n" );
-    if (handle)
-        FIXME( "Unsupported cancel handle\n" );
-
-    ret = getaddrinfoW( name, servname, (struct addrinfo *)hints, result, overlapped, completion_routine );
-    if (ret) return ret;
-    if (handle) *handle = (HANDLE)0xdeadbeef;
-    return 0;
+    if (!timeout || (!timeout->tv_sec && !timeout->tv_usec))
+    {
+        /*
+            Reasonable defualt timeout time of 3 seconds
+            For some reason, windows doesn't have a default one.
+            We do NOT want an infinite timeout. Ever!
+        */
+        timeout->tv_sec = (long)3;
+    }
+
+    /* Args for a thread function have to go in a struct */
+    *getaddrinfoWParams_struct = (getaddrinfoWParams) {
+        .nodename = name,
+        .servname = servname,
+        .hints = hints,
+        .res = result,
+        .overlapped = overlapped,
+        .completion_routine = completion_routine
+    };
+
+    getaddrinfoW_thread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)getaddrinfoW_wSTRUCT, getaddrinfoWParams_struct, 0, NULL);
+    if ( !getaddrinfoW_thread ) /* Null on creation (no handle) means an error occured */
+    {
+        SetLastError( WSAECONNABORTED );
+        return WSAECONNABORTED;
+    }
+    /* Get time since started, and subtract from time started now */
+    QueryPerformanceFrequency(&Frequency);
+    QueryPerformanceCounter(&StartingTime);
+    EndingTime = StartingTime;
+    ElapsedMicroseconds.QuadPart = EndingTime.QuadPart - StartingTime.QuadPart;
+    ElapsedMicroseconds.QuadPart *= 1000000;
+    ElapsedMicroseconds.QuadPart /= Frequency.QuadPart;
+
+    while (ElapsedMicroseconds.QuadPart < (LONGLONG)timeout->tv_usec + ((LONGLONG)(timeout->tv_sec))*1000000 )
+    {
+        GetExitCodeThread(getaddrinfoW_thread, exitCode);
+        if ( *exitCode != STILL_ACTIVE)
+        {
+            ret = (int)*exitCode;
+            break;
+        }
+        QueryPerformanceCounter(&EndingTime);
+        ElapsedMicroseconds.QuadPart = EndingTime.QuadPart - StartingTime.QuadPart;
+        ElapsedMicroseconds.QuadPart *= 1000000;
+        ElapsedMicroseconds.QuadPart /= Frequency.QuadPart;
+    }
+    if ( *exitCode == STILL_ACTIVE )
+    {
+        /*TerminateThread(getaddrinfoW_thread, NULL) */ /* can't really tell what will get terminated so we kinda just have to let it leak */
+        SetLastError( WSAETIMEDOUT );
+        return WSAETIMEDOUT;
+    }
+    else if (ret == 0)
+    {
+        if (handle) *handle = (HANDLE)0xdeadbeef;
+        return 0;
+    }
+    else return ret;
 }
 
 
-- 
2.33.1

